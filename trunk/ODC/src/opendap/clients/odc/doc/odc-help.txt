#Introduction
(help file revised 17 April 2011)

This is the OPeNDAP Data Connector (ODC). Using the ODC you can search for and retrieve datasets published by OPeNDAP data servers. OPeNDAP servers (also known as DODS servers) located at major institutions around the world serve a wide variety of data including: climatic data, satellite imagery, and ocean sensor results. The ODC allows you to find these datasets, download them to your machine, save them, and import them into client applications like IDL, Matlab, SPSS, Excel, or into databases such as Access and Oracle. The ODC is your gateway to terabytes of scientific data and imagery.

http://www.opendap.org/ODC/

To report bugs or make comments use the feedback tab.

You may also directly contact either:

Dan Holloway <d.holloway followed by gso.uri.edu>
John Chamberlain <odc_help followed by opendap.org>

The development of this software was funded by the National Oceanographic Partnership Program (http://www.nopp.org/).

#Startup and Shutdown

Start the ODC by running the executable ("odc.exe" on Windows, "odc" on UNIX). Configuration parameters for startup are in the file "startup.ini" which must be in the base directory (unless you are doing a manual startup (see installation instructions for your system). Note that a 1.4 or better JRE must be available. The Windows package includes this JRE and on Mac OS X Jaguar or better it is built-in.

To shutdown the ODC click the "x" in the upper right hand corner of the application window's title bar.

The ODC has various configuration settings. These are stored in a file called "config.txt". You can view these settings by using the IPS command "show config" (see topic Third-Party and Command Line Support for information on using the console).

*** Base Directory ***

Your base directory on startup will always be the first status log entry (see Status and Errors topic below for how to display). You can change the base directory by supplying the desired directory path as an argument to your startup command. In a unix install this startup command is usually a script. In a Windows installation the application argument can be specified in the startup.ini file as the "ApplicationParameter" value.

#Quickstart

The ODC uses a tab-based interface. This is the help tab.
The tabs are persistent: you can leave a tab and come back to it and it will be unchanged.
As you do the quickstart you can come back and forth to the help tab without affecting your work.

Operating the ODC involves three steps:

	(1) identify the dataset you want to use (Search)
	(2) retrieve its structure and make a sub-selection of the data if desired (Retrieve)
	(3) output or view the data (View)

The controls for these three steps are grouped onto three tabs accessible at the top of the screen.

Follow along to learn how to do these steps:

	1 - go to Search / Dataset List tab
	2 - go into the "University of Rhode Island ..." folder
	3 - go into the "1.1km Northwest Atlantic AVHRR" folder
	4 - single click (DO NOT DOUBLE CLICK) on "Pathfinder SST"; your choice will highlight
	5 - single click the red "To Retrieve" button at the top of the screen
		[you should now move automatically to the retrieve panel]
		[Pathfinder SST will be listed as one of your selected datasets]
		[notice that it is highlighted; this means it is the active dataset]
	6 - navigate the directory tree by double-clicking the folders to a month of your choice
		[a list of data files for the month will appear on the right]
	7 - double click one of the files; this will load its structure
		[the structure of the file will appear in the pane below]
	8 - click the check box next to the "dsp_band_1" variable
	9 - modify the array ranges so they read "0:10:6143" (enter key "saves" the change)
		[this specifies you only want every 10th value in the array]
		[we subset the data like this because a 6143 x 6143 matrix 
		would take a lot longer to process without adding much more to see]
		[shortcut: use the "step" drop-down box below to set the step to 10]
	10 - select "Plotter" in the drop-down list next to the "Output to" button
	11 - click the "Output to" button
		[you will automatically move to the View/Plot pane]
		[the data will automatically be loaded to the plot pane]
	12 - single click plot type "Pseudocolor" if it is not already selected
		[the x and y values will automatically be picked for you]
	13 - single click the blue "Plot" button
		[a plot of the data will appear in a separate window]
		
Congratulations you have done a plot!

Each of the screens above has much more functionality and options than we have explored here.
Read the rest of the help when you want to learn more. Visit the web site's plot gallery (http://opendap.org/ODC/gallery) to get detailed walk throughs for how do plots of all types.
	
#About Network Resources, Firewalls and Proxies

It is important to realize that the ODC does its work by accessing servers located all over the internet. These connections may not always be active or servers may be down or malfunctioning. In some cases a server will not be responsive and you will see the progress meter in the lower right-hand corner of the display strobe persistently. You can stop such actions by double-clicking the progress meter.

During network accesses (by default) there is a yellow box that appears in the center of the screen. You can disable this box by changing a configuration setting.

--- Firewalls and Proxies---

You may work behind a "firewall" which prevents normal access to the internet. The ODC can still operate as long as there is an HTTP proxy server available to your machine. If your browser works, but you are behind a firewall it is probably because the browser is using a proxy server which the ODC can use as well. To set up the ODC to use your proxy you need to set configuration settings (see Configuration topic in this help for how to do that) called "proxy.Use", "proxy.Host" and proxy.Port". proxy.Use should be set to "Yes". The host setting should either be a machine name like "sodastraw.mycompany.com" or a numeric IP address like "123.456.789". The port setting will be an integer like "8080". This integer must be between 0 and 65535.

If you do not have a proxy server or do not need to use one then proxy.Use should be set to "No" (the default).

The ODC has limited support for authenticated proxies. Authenticated proxies are proxy servers that require a username and password. The ODC supports "Basic" authentication only. If your web proxy uses Digest, NTLM, Kerberos or other authentication scheme it will not work. Check with your network administrator. If you want to use Basic authentication set the following properties:

proxy.UseBasicAuthentication  (set to "yes" or "true")
proxy.Username
proxy.Password

To determine the host and port of your proxy either ask your administrator or look in your browser settings. For example in Netscape 4.72 the proxy settings can be found under the menu Preferences / Advanced / Proxies.

#About Memory

The ODC is a memory-intensive application especially if you use it for plotting. You can increase its responsiveness by setting the minimum heap memory (the starting memory for the application). You should increase the maximum amount of memory available to the program to match the total amount of memory in your computer unless you have some special reason for restricting it. If you set the maximum memory higher than the total amount of real memory in your system the program will use "virtual memory", ie disk space, to serve as the memory. This is much slower than real memory, RAM, and wears the disk. For these reasons it is recommended that you try to match the maximum memory setting to actual amount of RAM available to the application.

These settings are accomplished by adding switches like this to the startup command:

     -Xms40m     starting memory of 40 megabytes (if no switch is present defaults to 2m)
     -Xmx300m    maximum memory of 300 megabytes (if no switch is present defaults to 64m)

If you are operating under Windows you can find these settings in the startup.ini file. In this file the format of the entry is like "Option = -Xms40m". On the Macintosh these settings these settings are in the app builder properties file. In a Unix environment they are the first parameters to the java startup command (e.g. "java -Xms40m -Xmx300m ... etc").

It is recommended that users increase both the starting and maximum memory to at least the levels shown above (40 starting, 300 maximum) to get a standard level of performance.

Failing to change maximum memory setting can be particularly debilitating because it prevents the ODC from using the full resources of your system.

Note that the amount of memory used will often be much larger than the raw amount of memory a dataset consumes. For example, a dataset that consumes 20 megabytes as a raw stream might easily use 80 megabytes when it is being manipulated in memory. The reason for this is that for some operations, notably plotting, the data must be held in multiple buffers simultaneously.

#About Undo, There is None

The ODC does not have an undo feature like you may be used to in other desktop applications. The reason for this is that it is programmatically complex to implement undo procedures and it strains memory. For example, if you are doing cell-level modifications on a dataset that takes up 500 MB of memory, the program would have to keep an entire copy of the previous version of the data in memory to support an undo. The operation would also be more time-consuming because all 500 MB of memory would have to be copied before the modification could be started. In the interests of maximizing speed and memory there is therefore no undo.

Since there is no undo it is recommended that when doing modifications you maintain checkpoint versions of your data on disk so that in the event that a modification goes wrong you have a backup copy of the data.

#Status and Errors

The ODC keeps track of most major application actions in its status log. It also records all errors and warnings. To view status or error information go to the View / Text tab. At the bottom of the screen are buttons that will output the status and error information to the text windows. If you encounter a problem and want to report it to the developers please copy and paste your status log into the message to us. Errors always print out at the end of a status log dump. You can also dump just the errors and warnings by clicking the "Show Errors" button.

#Configuration

The default settings for this program will work for most people however you may need (or want) to tweak its configuration. For example, if you are behind a firewall you will need to set the configuration to use a proxy server.

There are two ways to read and modify your configuration settings:
(1) edit the configuration file directly
(2) use the console

The configuration settings for the ODC are in a file called "config.txt" located in your ODC base directory. This file is created automatically the first time you run the ODC. Your base directory is listed as the first entry in the status log (see topic on status and errors).

You can use the console available on the View / Text tab to display or modify configuration settings. To show all settings enter "show config" in the text box at the bottom of the screen and press the Enter key. Likewise you can use the "set" command to change a setting. To display all the commands enter the command "help" or "?".

#Searching and Retrieving

The top row of tabs in the interface gives your search options. Favorites are your favorite data sets. Initially this list will be empty. Recent is the 20 (by default) most recent data sets selected. GCMD is the Global Change Master Directory sponsored by NASA. The dataset list is a general catalog of known OPeNDAP servers and their data. Note that the favorites and recent will not be visible if you are in read-only mode (eg running the program directly from a CD-ROM).

The GCMD interface is not immediately accessible when you start the ODC. This is because it takes several network accesses to load it. If you wish to load the GCMD search interface go to the Select / GCMD tab and click the "Access GCMD" button in the center of the screen.

After you have located one or more data sets of interest you must move them to the retrieve panel by clicking the "To Retrieve" button. You can move multiple files by multi-selecting holding down the Ctrl key.

The information used to populate the dataset list comes from a file included with the ODC distribution called "datasets.xml". You can retrieve the latest version of this file from unidata.ucar by clicking the "Refresh Dataset List" button on the Dataset list tab. This will overwrite your local file cache with the remotely maintained copy at UCAR.

* Any GCMD spatial constraint you specify will be applied to all GCMD queries. See the section below on the spatial constraint panel for more information on using it.

* Double clicking on an item in the Favorites or Recent tabs will cause its information to be displayed in the area below

* Dataset List Search: to use this search enter search terms in the box and click the "Search" button; the search is by default an "OR" search that includes any of your terms; if you want to guarantee a term is there ("AND") put a "+" in front of that search term; when the search completes the tree will be updated to only include matching nodes; to restore the tree to show all nodes make the search box empty and click the "Search" button again

#Subset and Select

When you send one or more dataset locations to the Retrieve panel, the panel will be activated and the dataset location title will be listed in the panel on the upper left. 

The retrieved datasets panel lists the dataset locations which you have identified. There is a red button "?" to the left of each item. The "?" (Info) button will retrieve information about the location and display it in a text panel to the right. If the item is a directory (indicated by a folder icon) a directory tree will appear to the right in the top half of the panel when the location is selected (clicked once).

The buttons are red to indicate that they do a network access. If you have network problems or the site holding the dataset is unavailable for some reason there may be a long delay before a response occurs.

The directory tree for a given directory dataset item is not fully displayed when it is first shown. Only the first level of the directory is shown. To see subdirectories you must double-click on the desired sub-directory. Each time this is done a network access is made to further discover the subdirectory. If a directory has been not been discovered an ellipsis ("...") appears after its name. This means that the ODC does not know what is in the directory and it will require a network access to find out. If there is no ellipsis then you can expand the directory to see what is in it without making a network access.

When you select a directory any files in the directory will be shown in the list box to the right of the directory tree.

You may subset one or more directory files by double-clicking the file name. The criteria for that file will appear in the lower pane of the Additional Criteria area. Any criteria specified here will be applied to all the selected files in the directory tree.

* Display the DDS (structure information) for a dataset by holding down the control key and double-clicking the dataset. Display the DAS (ancillary/descriptive information) for a dataset by holding down the shift and control keys while double-clicking.

* You must select a dataset for a download to occur. In the case of a directory you must select one or more files within the directory, just selecting the directory itself will do nothing. The files you have selected will be listed in the "Selected Datasets" list box in the lower left of the retrieval panel.

* You may select more than one item in a list or tree by hold down the Ctrl or Shift keys. Ctrl will add to your selection and Shift will cause your selection to be extended to the place of the mouse click

* You can enter (or paste) an URL manually into the location box at the top of screen and pressing the "Add" button. The URL will be added as a new dataset location in the selected datasets lists.

* The location bar at the top of the retrieve panel shows the URL for the current subset. Note that in the case of directory URLs there will be no file name in the URL in the location bar. You can use the location bar to enter an URL manually by clicking the "Add" button.

--- Constraints ---

To constrain the results from dataset use the lower pane of the "Additional Criteria" panel. If the selected dataset has fields that can be constrained they will appear here. In the case of an array you can specify the starting index, ending index and stride (ie step). For example, if you specify "4:2:12" you will get data for array indices 4, 6, 8, 10, and 12. In the case of sequences you can use the drop down box to specify a relation and then give a quantity in the text box next to it. For more information on constraining a dataset see the OPeNDAP web site.

#Outputting

There are various output options indicated by the buttons in the lower left quadrant of the retrieve panel. When you select one of these options they will be applied to all of the selected datasets as indicated in the "Selected Datasets" list box as long as the operation is valid. (For example, you cannot send a gif to the plotter; you can only send OPeNDAP datasets to the plotter.)

The selected datasets list shows the estimated size of the dataset if possible. This measurement is shown in units of bytes (B), kilobytes (K), megabytes (M) or gigabytes (G). The estimate does not include any sequences or string data.

If you output to a file specify a filename or directory in the box provided. The elipsis button (...) will give you a file dialog box you can use to navigate your machine's directory tree.

If you specify a directory (the path ending in a slash) then when the file is saved the existing file name (or names) of the selected URL(s) will be used.

The supported output file formats are:
	Binary - the exact file as it exists on the server (only valid for non-OPeNDAP sources currently)
	ASCII - A readable printout of the data in bracketed format (only valid for OPeNDAP sources)
	Formatted - A readable printout that has been flattened into tables (only valid for OPeNDAP sources)
The formatted output is appropriate when you want to read the data in a two-dimensional way. Also, the formatted output is specifically designed to be easy to parse.

If you attempt to output a file in a non-supported format you will receive an error message to that effect.

Data Binary Output Not Supported:
Currently (as of version 2.41) data files which the server can read as OPeNDAP sources, for example, NetCDF (*.nc) and HDF files, CANNOT be returned in the binary format. You can only return the ASCII or formatted ASCII formats for data files. Binary file retrievals are only possible for non-OPeNDAP sources such as images (.gif, .jpg, etc), text or other non-OPeNDAP sources. This is a limitation of the current OPeNDAP server design.

#Timeouts

You may get a timeout error indicating that the ODC did not want to wait any longer for data. Some servers may require longer timeouts than normal because they have data archived using complex retrieval systems. This is true of MODIS data for example.

To adjust timeouts change the configuration settings timeout.InternetRead and/or timeout.InternetConnect. The connect timeout applies only when the ODC is first connecting to the server and the read timeout applies once data retrieval has begun.

One way to change these settings is to use the command interface found on the View/Text panel. For example, issuing the command:

	set timeout.InternetRead 30

Would set the timeout to 30 seconds. You can read more about entering commands and using the command interface in the next topic (Third-Party and Command Line Support).

Another way to change this setting is to edit the config.txt file in the ODC base directory.

#Scripting: Python Support

The console (View / Command tab) allows you to enter in commands to the program and to programmatically control the ODC.

Commands prefixed by an exclamation point ("!") will be sent to the ODC. Type "!help" to see those commands". See the help topic "Third-Party and Command Line Support" for more information on this functionality. All other commands are sent to the Python interpreter.

Example: type "print 2+5" and press the enter key. The result 7 will appear on the next line.

The system automatically defines a script directory. By default this is "scripts" in your ODC base directory. You can place Python script files here to be imported. Type "!list scripts" to see a list of the files in the scripts directory. Type "print sys.path" to see the directories which scripts are accessible from. You can append to the path normally as in Python to add an additional directory for imports.

The file editing capabilities of the ODC are useful for interactively building scripts. See the topic "Editor" for more information.

For more information on scripting see the help topics for Interpreter, such as "Interpreter - Scripts" for the basics on running a script.

#Editor

The ODC has a text editor capability. Go to the tab View / Editor. The editor can work with multiple files at once.

There are several configuration settings that control line wrapping and column count. These settings affect both the command console and the editor panes. Type "!show config" in the command console to see these settings.

#Third-Party and Command Line Support (Console)

* The ODC has a command server called the "interprocess server" which listens by default on port 31870. You can issue commands to the IPS by entering them command console prefixed by a "!". The exclamation point indicates that the command is to be sent directly to the ODC, and is not for the Python intrepreter.

       STEP-BY-STEP Guide to Executing a Command
	   
     - find the "View" tab at the top of the screen, click on it once
     - find the "Command" tab below this, click on it once
          The cursor should be a vertical line blinking in white text area
          The cursor should be preceded by a prompt string (by default ">>>")
     - type an exclamation point "!", this means the command is for the ODC, not for the Python interpreter
     - type the command desired, it should appear after the prompt (>>>)
          you can also copy and paste a command from somewhere else
     - press the enter key to execute the command
          the results will appear starting on the line below the prompt

* Any valid Python command can be entered. See the topic "Interpreter - Commands" for more information. For example,
	>>> print 2+3
	7
		  
* The command "!help" will show you all the ODC-specific commands

* The command "!show config" will show you the current preference and configuration settings for the program

* You can issue the same commands by connecting from a third party application such as a telnet client.

* Enter "?" or "help" in the command line at the bottom of the text view screen to see supported commands for the interprocess server. See the step by step instructions above for entering a "help" command.

* The Interprocess Server is used by the Excel and Access add-ins to do data imports

* The configuration settings for the server are accessible from the console and default to:

InterprocessServer.port = 31870
InterprocessServer.on = Yes

#Program Directories and Files

* The ODC uses various files and directories installed below its root directory relative to the "base directory". The base directory is normally where the application has been installed. The relative paths are:

	config.txt
	datasets.xml
	exp.txt
	ECHO_static_valids.xml
	/preferences
	/scripts
	/ImageCache

* By default the PC launcher automatically sets the base directory to wherever the launcher executable is located. You can specify a different directory adding the following line to your startup.ini file:
	ApplicationParameter = [desired directory]    (for example, "c:/usr/John Smith/odc")

* If you do not use a launcher you should supply the name of the base directory as a startup argument. If you supply no base directory the working directory (user.dir) will be used.


#Spatial-Temporal Constraint

The spatial-temporal constraint panel can be used to create a spatial or temporal constraint on your search.

To create a spatial constraint surround the desired area on the map with the white selection rectangle. You can modify the location and shape of the rectangle either by manipulating it with the mouse, editing the coordinate text boxes or selecting an item from the gazetteer. After you have selected an area you must make sure the "Apply" checkbox is checked. If this checkbox is off no spatial constraint will be applied.

To create a temporal constraint enter the From and To dates in the boxes provided. The temporal constraint will be applied automatically if there is any text in any of the six temporal entry boxes. If you only make an entry in "From" then there will be no "To" constraint and vice versa. If you leave the year blank, but enter a month or a day then the From year will default to "0001" and the To year to the current year. The From month defaults to "01" and the To month defaults to "12". The From day defaults to "01" and the To day defaults to "31".

The gazetteer has preset coordinates for well-known regions. The first list box contains region types. The second list box has the entries for the selected type. It updates automatically when you select a region type. The third list box has custom regions. By clicking the Add button you can define your own regions. These will be added to the gazetteer file. The gazetteer file is a text file the location of which is specified in your configuration. It has a self-evident format so you can modify it or provide your own gazetteer.

#Plotting

If you would like to graph your data the ODC has the ability to create plots of various kinds such as line, scatter, histograms, pseudocolor, contour and vector plots. A good way to get started plotting is to go to the OPeNDAP online gallery of example plots and see how those plots were done. This will give you an idea of the range of plotting capabilities and serve as a guide to setting up the plots of the various types. Each example in the gallery has a detailed set of directions for duplicating the plot.

Selecting and Loading the Data

First add the URL for the data you wish to plot to the retrieve panel and constrain it, if desired. In most cases you will need to constrain arrays to two dimensions or less. Use the "To Plotter" button in the retrieval panel to download the data and make it accesible to the plotter. This will load the data off the network into memory. Note that doing this involves a network access as indicated by the red color of the "To Plotter" button. If the load is successful the dataset will be listed in plotter panel. Select the loaded item from the list. The dataset structure will appear in the pane below. You are now ready to define your plot.

If you select multi-dimensional arrays you must restrict them to one or two dimensions. The plotter will not process arrays with more than two dimensions. To restrict a dimension constrain it to a single value. For example, the constraint X[1:100],Y[1:250],Z[17:17] restricts the Z-dimension to a single value. This turns the array into a two-dimensional array.

Defining the Plot

To define your plot first pick one of the plot types, such as "Line", from the combo box. The plot definition pane may change to support the plot type chosen. The definition area will then allow you to specify which value(s) you want to plot. Choose a variable to plot from the "values" combo box. The contents of the X- and Y-Axis combos may change depending on which values you are plotting. If you are plotting a mapped grid, the axes choices are determined automatically. The interface will show the dimensions for that value and allow you to specify which dimensions should be the x and y. In the case of a line plot you can only select one x or y. All other dimensions must be constrained.

Dimensions that are not assigned to an axis must by constrained and a text box will appear allowing you to enter a constraint. The constraint is a comma-separated list of values or ranges, for example, "1,2,4-6,9,13-17". These numbers are the index numbers of the data not the data values themselves. If there are more than one dimensions to constrain only one of the dimensions may have more than one index specified by the constraint. If you specify more than one value in a constraint multiple plots will be generated--one for each index in the constraint.

Output Options

Once you have defined a plot you can output the plot by clicking the "Plot" button. There are various output destinations available via the drop-down list next to the plot button. You can also change the scale of the plot with the zoom factor controls to the right of the plot button area. For more information on zoom factor see the topic Scaling. For more information on the output destinations see the topic Output.

Using the Table View

You can also plot from data contained in the table view. If you click the "Table View" radio button in the upper left the definition pane will change to allow you to enter one or more ranges to get the data from. Enter the ranges in spreadsheet fashion, for example "A3:B15". You can add ranges together by separating them with a comma, for example "A3:A15,D5:D23,M6:M400". If you add ranges they must have at least one identical dimension. For example, you could aggregate a 3x20 matrix and a 3x60 matrix but you could not aggregate a 4x5 matrix and a 3x15 matrix.

Plotting Data in a File

If you would like to plot data from a file, store it in CSV (comma-separated values) format and then load it into the table view. Once it is in the table view it can be plotted as described in the paragraph above. In a CSV file fields are separated by commas and records are separated by new lines. If there are strings in the data they can be delimited by quotation marks. To escape a quotation mark, double it. For example, "Satellite AR4078 (""AEGIS"") Data" will evaluate to [Satellite AR4078 ("AEGIS") Data].

Missing Values

The "Missing" text box allows you to enter one or more "missing values" for the data set. A missing value is a data value that is to be treated as null. These values show in the plot as a particular color indicated by the color specification. If there is more than one missing value separate them with spaces in the box. You can sometimes determine the missing value(s) by examing the global attributes of the data set (use 'show descriptions' in the constraint panel). The missing values assigments are part of the color specification.

If the dataset's attribute information contains an attribute for the selected variable that starts with the word "missing" those values will automatically be parsed and used as missing values. You can have the ODC attempt to calculate the missing values for you which it does by default if no missing values attribute was found. This calculation will double your data memory requirements temporarily and take time proportional to n*log(n) where n is the number of data elements. You can turn it off via an option setting.

Plotting Objects and Overlap

Within a given plot object, such as an axis, legend or scale, there should be no overlap of text or other items as long as the screen DPI option is set correctly (see Screen DPI Calibration). Plot objects can be overlapped, and in this case a text collision can occur. For example, label of the base point of the y-axis could overlap with the label of the base point of the x-axis. To avoid problems like this you may have to manually adjust the plot object location or use parameters like Omit Origin Label on an axis.

#Plotting Expressions

You can plot Python expressions by loading or creating expressions in the data editor (View / Data). Script files that contain a specification for a mathematical formula, or formulas, which can be plotted are called "plottable expressions". A plottable expression must begin with the directive #!odc. This tells the ODC that the file is not a normal text file, but is expression code. The difference between a data script (qv) and a plottable expression is that a datascript always has a "value=" or "$0=" line. Both must begin with the line "#!odc". When an expression data type is selected the plotter's variable panel will automatically show the settings for configuring the plotting of the expression. Three types of expression plotting are supported:

Cartesian   (example: y=2*x)

Polar       (example: r=5*sin(theta))

Parametric  (example: x=2*sin(t)
                      y=3*cos(t) )

When the expression is plotted the ODC substitutes numeric values for "substitution tokens" which are specified in the variable definition panel. By default the substition tokens are "x", "theta" and "t". If you are using these letters already in your expression you will need to change substition token to be dollar-sign-prefixed ($x, $y, $z, $r, $t, and $theta) or underscore-prefixed (_x, _y, _z, _r, _t, and _theta). Underscore prefixing is the internal coding standard to which all expressions get converted before final evaluation. Note that the ODC is smart and if it sees "$x" or "$t" in your expression it will automatically use $-sign tokens instead of plain tokens. For example, if you have the token $x in your expression, the token plain 'y' will be ignored. Also, note that Cartesian is preferred to Polar which is preferred to Parametric. So, if you have x and y, then only the x-value will be substituted and the plot will be treated as Cartesian, etc.

The range of the expression is determined by the independent variable:

x_range_begin = 0
x_range_end = 1

or (for polar plots)

theta_range_begin = 0
theta_range_end = 0.25 * math.pi

or (for parametric plots)

t_range_begin = 0
t_range_end = 1

The dependent variable range can be set manually (eg y_range_end = 25) or, if absent, will be calculated automatically. If the ranges need to be calculated automatically then the plot calculation will occur twice, once to determine the ranges, then again to do the actual plot. The interval for Cartesian and polar plots is determined by the resolution of the output device. For example, if the output is the preview pane and the plot area in the preview pane is 600 pixels wide and the range is 0 to 1198 on the x-axis then there will be 600 calculations and x will be stepped by 2 for each one. The default indepenent range is 0 to the number of pixels in the output area.

For Polar expressions you provide an expression in terms of theta (the angle) and the plotter uses the value of the expression as the radius.

For Parametric expressions you provide multiple expressions in terms of a parameter, by default "t" or "$t". The L-values are determined by the index number in the L-value column of the variable definition panel OR by a comment designator in the expression of the form "# X" in the text of the expression. To set the range of a parametric plot set the variables "t_range_begin" and "t_range_end":

t_range_begin = 0
t_range_end = 1

The default ranges are 0 and 1 as shown above.

BEWARE SIDE EFFECTS: Be cautious about including anything in the expression for the dependent variable which would cause a side effect (such as setting a third variable). The reason for this is that the dependent variable expression is evaluated two or three times during plotting: once to determine the range of the dependent variable (if it is not specified explicitly), once to determine how many points need to be stored and to allocate memory, then finally to determine the point coordinates themselves.

IMPORTS: If you need to make an import or other statement, place it in the script. Any line which does not contain an equals sign (=) will be exected only once when the script is first compiled. For example,

#!odc
import math
y=sin(x)

*** Continuous versus Point Plots ***

If the plot is continuous it will be rendered as a series of line segments between the points. If it is a point plot separate pixels will be plotted.

*** Ranges and Steps ***

You may need to specify ranges and steps for the plot so the ODC knows what values to calculate. For a cartesian plot you can leave the step blank and the ODC will automatically calculate a value appropriate for the resolution of the output area. For example, if you are plotting and expression with a y L-value to the preview pane and it has 400 pixels in the x-dimension for the specified range then 400 calculations will be done, one for each pixel along the x-axis. Using the automatic calculation for Cartesian expressions ensures that you getting the best resolution and computing the fewest number of values necessary.

#Plotting Lines

When plotting lines directly from data (not using a table view) there are following ways of defining the data variables:

     Independent      Dependent
       none            1 x/y      lines only (scatter plots must have 2 variables)
       none            slices     lines only (scatter plots must have 2 variables)
     1 x/y/slice     1 y/x/slice
     1 x/y/slice       n slices
       n slices        n slices    (number of slices must match for both variables)

In all cases only vectors (one-dimensional variables) may be used as line/scatter plot variables.

It is necessary to select x and y vectors of the same length. If the vectors are of different lengths an error will occur.

#Plotting - Axes

For two-dimensional plot types (vector and pseudocolor) you can select what kind of axes the plot displays. If the data is gridded it may come with map vectors that associate specific values with the axes. If this is the case the axes selection will be automatic and will be reflected in the variables pane.

The reverse check box allows you to choose the order of the axis values, ascending or descending. Sometimes you may notice that when you select a variable or dataset the reverse default is checked. The reason for this is that the map vectors in the data for whatever reason are in descending order and the plotter has automatically chosen to reverse them for you. This will often be the case for older data that was originally designed to be outputted to a line printer where the graphical origin will be the top left instead of the bottom left.

If you choose "indexed" for the axes then then plot will show the one-based index numbers data rows/columns. The usefulness of this is that sometimes you may wish to know exactly what row/column is containing certain data values.

Axis Parameters:

   Omit Origin/Endpoint Label - If selected then the origin/endpoint label will not be drawn. The renderer assumes you do not want any drawing at all beyond the coordinate origin/endpoint if these options are selected, so if some other element, such as another tick label or the axis label extends beyond the end of the axis then it will be cut off.

#Plotting - Line and Scatter Plots from a table

If you use the table view to set up your data ou have three options for defining your data:
   1 one or more linear ranges with the same length
   2 one or more sequential 2xN ranges
   3 one 2-D array with the each line in a row or column

In each case you can optionally specify an x-mapping. In each case the system will decide which option you picked depending on your input.

In option 1 each range will make a new line. In this option the y-values must be sequential.

You must use option 2 if you have lines of different lengths. In this case the first row/column in the range is considered to be the x-value (or index) and the second row/column is the y-value. If the x-values are integers you can have a x-mapping (see below) for the real values.

Option 3 is possible if you have a large number of lines in a rectangular array. In this case a radio button allows you to specify whether the lines are in the rows or the columns. The values in the array are y-values. You can also specify a mapping as in the other two options.

*** Line IDs ***

If you add each line separately you can specify an ID for the lines. This is the string that will appear in the legend.

#Plotting - Annotations

The plotter can automatically generate a range of annotations and you can add custom text annotations. 

*** Text ***

Text is automatically generated by the plotter the first time it plots a dataset (in a row). It will generate text for the axes and the title as long as it can determine the information. You can see these entries by visiting the "Text" tab in the plotting definition area. You can delete them, modify them or add your own.

*** Legend ***

The legend shows the color bar for pseudocolor plots. The rotation is relative to the horizon and can only be in increments of 90 degrees (values other than 0, 90, 180 and 270 are ignored). The size is the length of the bar in screen dots (72 dpi). If you do not enter a size the following defaults are used:

y-axis orientation: size = y-axis length
x-axis orientation: size = x-axis length
plot, top/bottom orientation: size = x-axis length
plot, left/right orientation: size = y-axis length
canvas, top/bottom orientation: size = canvas width
canvas, left/right orientation: size = canvas height

In general you should use a rotation of 0 for horizontal legends and 270 for vertical legends. The label is automatically rotated the same way.

*** Scale ***

The scale is a line that shows relationship between distances on the image to distances in reality. You must enter the real scale length and scale length relative to the length of the x-axis. For example if the x-axis covers 100 miles in reality and you want the scale be 20 miles wide (1/5 the length of the x-axis) you might enter a labels of "20 miles", an X-length of "100" and real scale length of "20". If you want to control the font/color/size of the label, leave the label blank and add a custom text annotation.

Currently the scale only has one style: a line with out-turned ticks at each end.

#Plotting - Layout

The plotter locates text, legend/colorbar and scale on the plot using a layout system with six quantities: object, orientation, alignment, h/v offset and rotation.

The relative object is the thing the object being placed is relative to. For example if you wanted the text to be in the upper right of the canvas you would pick "Canvas", but if you wanted it to be in the upper right of the plot area you would pick "Plot" as the object.

The orientation is the place on the relative object where the text/legend is being placed. The alignment is part of the text/legend that is fitted to the orientation location. For example, if your object is "Plot", orientation is "Top Left" and alignment is "Center", then the center of the text will be positioned at the top left of the corner of the plot area.

The offsets allow you to make absolute x/y ajustments in screen pixels to the placement location.

The rotation is relative to the horizon. If the text is like a hand of a clock, 0 degrees would be at 3 o'clock, 90 degrees would be at 6 o'clock etc. Legends and scales can only be oriented in increments of 90 degrees, but text can have any rotation.

If the bottom of the text seems to be extra high this is because the alignment takes into account descenders--characters such as 'y' and 'q' that have tails below the baseline. The text rectangle is placed so that its bottom includes the full descent of all possible characters.

#Plotting - Output

The output options are controlled by the drop-down list next to the blue Plot button.

Preview     - the preview tab will be activated and the plot will appear therein
              only one plot can be active at a time in the preview pane
              if you plot to the preview pane you lose any previous plot that was there

New Window  - a new window will be created for the plot, if you multiplot 20 plots to
              new window you will create 20 new windows

External Window  - use the external window for the plot; the external window is a single
                   separate window; if you multiplot 20 plots to the external window each
                   plot will appear in the window in turn separated by a delay called the
                   the multiplot delay which is settable via the options panel

Printer     - a dialog will appear requesting that you select a printer and the plot will
              be sent to the printer

Full Screen - the entire screen will be used to display the plot
              press the escape key or the spacebar or click anywhere in the window to close it

Thumbnails  - the plot(s) will be sent to the thumbnail pane; the thumbnails are shrunken to
              a fixed width (by default 100 pixels) and laid out in a matrix on the thumbnail
              pane; you can change the width of the thumbnails with an options setting; the
              thumbnail view is useful for viewing many plots at once; use Shift-click to select
              thumbnails; double-click on a thumbnail to plot it again

Image       - you will be prompted for a file name and location and the plot will be stored as
              a PNG image file

#Plotting - Scaling

The scale tab has controls that allow you to define margins and scale for your plot. The scale is the relationship between data points and screen pixels. For example in a 1 to 1 scale there would be one data point for each pixel. In other words if you were plotting a 200 x 300 array in a pseudocolor plot the plot area would be 200 x 300 pixels in size on both the screen and the printer. You can change the scale by setting the zoom factor which has the following meaning:

 Max   - try to fill output area
  %    - make proportional, for example 50% means 2 data points per pixel
Custom - set the size to the exact dimensions shown

The scale may be applied to the plot area, the square region where the data is being drawn, or to the canvas, ie, to the entire window. The "margins" refer to the distance between the edge of the canvas and the edge of the plot area. All decorations, like axes, legends, titles, etc, must be able to fit in the margin or they will not be rendered.

For a 2D plot the axes are drawn in the margins so your margins must accomodate any axes or other annotations you want to include.

When you are using Max or % zoom factors the custom area fields will show current size of the output. You can specify either "Canvas" mode to set a width for the entire image including the margins, or for just the plot area.

As of 2011 the nominal resolution of most computer screens is 96 pixels per inch and the actual resolution is 85 ppi. Older systems (pre-2007) may have a 72 dpi resolution. Whatever your screen resolution is will appear by default in the Resolution text box. You can specify a higher resolution using the "Resolution" text box. This is useful if you are generating output for a printer or for printing. For example, for raster line art "Science" magazine prefers a resolution of 1200 dpi, so you would enter that as your output resolution if you were preparing a pseudocolor for that journal. Note that if you display a high-res image on the screen it will be gigantic.

*** Scale Units ***

The following scale units are supported:

		Pixels,
		Inches_Tenths
		Inches_Eighths
		Inches_Mils        // 1/1000"
		Centimeters
		Picas              // 1/6"
		Points             // 1/12 of a Pica

If you are working with fine lines you may want to use mils. On an 85 ppi monitor 10 mils equates to 1 pixel, a hairline. The problem with specifying in pixels is that if you print and your printer has, say, a 1200 dpi resolution, the line will be thinner than the line on the screen and may be too thin. By working in mils you will get similar results on both the screen and on paper when generating fine lines.

#Plotting - Histograms

The histogram plotter can show you the distribution of values in your data. It can operate on any single variable or slice from your dataset. The X-axis shows the extreme values from lowest to highest and the Y-axis shows the number of values. Histograms work by sorting all the values of the dataset into classes. Classes are sometimes casually referred to as "bins". For example, you could divide a country's population into age groups. The first class might be children (age 0-10), the second adolescents (age 11-14), and so on.

The main parameter when doing a histogram is the number of classes which can be set from the Options tab. If you select a small number of classes there will be only a few rectangles. If you select many, there will many narrow rectangles or lines in the maximal case. A setting of 0 classes will result in maximizing the number of classes for the current output. For example, on an 800x600 monitor the plot area for a full-screen display is typically 500 pixels wide. Thus, with a setting of 0 the plot could include up to 500 classes. Note that fewer classes than this may result because the value range is held constant. For example, if your plot area is 500 pixels wide and your data was the numbers 1 to 800 then the plot would be 400 pixels wide with each line representing a range of 2.

Histogram Reports

To get detailed information on a class single-click the rectangle. A popup box will appear showing range and count information for the class. Clicking on the plot area outside the rectangles will prompt you for a histogram report. This report is sent to the View / Text tab and you must go there to see it. It tabulates summary information about histogram.

#Plotting - Colors

In the ODC plotter you can specify colors via their HSB (hue, saturation, brightness) value. You can also specify transparency (called "alpha"). Each of these values ranges in hex from 00-FF and can be selected either numerically or using a picker.

In the HSB system colors are formed by starting with a pure hue and adding black (saturation) or white (brightness). If you want to specify white, make brightness FF. If you want to specify black, make brightness 00. 

The color specification appears as a list of entries in the box labeled "Colors". These entries can be saved to a file and used for any plot. Each entry has the following space-separated fields:

	DataFrom DataTo ColorFrom ColorTo Step Hue Saturation Brightness Alpha [comments, ignored]
	
The color step is the direction of the spectrum (ascending: red to blue, descending: blue to red) and whether the hue/sat/bri/alpha vary in synchronized way. The codes (not case-sensitive) are:
	
	SA - synchronized ascending
	SD - synchronized descending
	CA - continuous ascending 
	CD - continuous descending
	
For most cases you should use a synchronized descending step. This will tend to make the lower data values blue and the higher ones red. The Alpha is the transparency (0xFF for opaque and 0x00 for transparent). Normally a continous color step is only used when generating gray scale.

This allows you to specify a range of data to be plotted using a range of colors. If you want the colors to be opaque but vary continuously, specify -1 for the HSB parameters and FF for alpha (opaque). If you want to hold one or more parameters constant give them a value. For example,

	10.5 20.5 +1 -1 -1 80 FF -1 FF
	
This entry would cause the values between 10.5 and 20.5 to be plotted as an opaque, saturated, blue (80) which only varied in brightness. Setting the ColorFrom and ColorTo causes those values to be ignored.

	10.5 20.5 +1 FF50FF77 FF80FF77 -1 -1 77 FF
	
In this example the data range plots between green (50) and blue (80). The hue (-1) and the saturation (-1) are allowed to float, but the brightness is held constant at 77 and the opacity is also held constant at 100% (FF). Note that the ColorFrom/To field values have the order AHSB.

To get a better understanding of color systems and controlling color you may want to read the next topic, "Generating Colors".

#Plotting - Data Parameters

When data is plotted there are three key additional parameters to plotting it:

- data type
- range of values
- missing values

This information is necessary to create color specifications and do other plot processing. It is important to know that the plotter uses only set of data parameters--it does not maintain a different set of parameters for every loaded matrix in every loaded dataset. Calculating this information can be relatively expensive in terms of processing time so it is only recalculated under three conditions:

- the user requests a recalculation using the calculator button on the variables pane
- the data type does not match
- the array/list dimensions do not match

In other words if you plot one dataset and then another, if the second dataset has the same type and dimensions as the first the parameters will not be recalculated, but if either the data type or dimensions in the second dataset does not match those in the first, the parameters will be recalculated.

You can view the data parameters in the values area of the variables panel.

When a new color specification is created or colors are generated the current data parameters are used.

#Plotting - Using the Color Picker

The color picker is the dialog box titled "Choose Color" which comes up when you change a color.

To define a color you modulate four quantities: its hue, saturation, brightness and alpha. Click on square in these areas to change that quantity for the currently selected color.

The arrow keys move the last selected band (hue / sat / bri / alp ). Right arrow +1, left arrow -1, up arrow +16, down arrow -16.

The currently selected color is shown at the bottom left next the label "Color:". Inside this rectangle are two colors: on the left is the selected color, on the right is the "compare color". You can swap these two colors by clicking anywhere in the color rectangle.

The hex form of the color is shown next to the color rectangle. You will recognize this as the form of the color used in a color specification ranges. The format of the number is AHSB in that order. The ARGB number is also shown for the sake of comparison. You can enter an RGB number in the picker by clicking on the "ARGB" label and entering the 6-digit hex code for that color. You can find color mappings with these codes many places on the internet (for example: http://home.earthlink.net/~laanderson/colornet.htm).

*** TIPS ***

Copy a color -    to copy a color note that the compare color stays the same,
                  so switch the color to the compare color box, move to
                  to the place place you want to copy to and switch it back

Fine adjustment - to make fine adjusments use the arrow keys

Make white -      white = 0% sat, 100% bri (to make gray reduce brightness)

Make black -      black = 0% brightness (no light!)

#Plotting - Generating Colors

If you do not make a color specification then the plots that require color will make their own using the ODC's color generating ability.

You can use the color generator as well. Using the color generator is good way to get started creating a color specification. The color generator is controlled from the box labeled "Generate Colors" on the color specification tab.

There are two basic types of color systems: continuous and banded. In a continuous system the color varies continuously with the data. In a banded system, all the data within a given fixed range is mapped to the same color. In an ODC color specification if the "ColorFrom" and "ColorTo" for a range are the same then the range is banded. If they are different then the range is continous. A color specification can include both types of ranges if the user desires.

When you generate colors the range is determined by the total of ranges already in the specification (if there are no ranges then 0 to 1 is used). 

To generate a banded color system, enter the number of bands (N) and other parameters as shown. The color generator will create N new ranges that are each mapped to a single color.

To generate a continuous color system, pick the basic type (gray scale, multi-hue, full spectrum, little rainbow, weighted rainbow), then fill in the parameters appropriately. Description of the continous color systems:

  gray scale
        saturation is set to 0 and brightness is varied
        across the data range for a continuous gray scale;

  bw printer
        the full range of values is used continuously from
        00000000 to FFFFFFFF; on screen this will look
        strange but when printed will give the best
        possible gray scale

  multi-hue
        in a multi-hue system one or more hues are selected
        and then are shaded, tinted or toned for variance
				
  full spectrum
        the data ranges across the full range of possible
        hues; the user can fix saturation and brightness
        to particular levels (100% 100% is the default);
        the user can also rotate the spectrum (by default
        it begins/ends in the middle of red, hue 00)

  little rainbow
        the data ranges across a limited part of the spectrum
        that the user selects; in a little rainbow one of 
        the three primary colors will receive emphasis

  weighted rainbow
        in the standard spectrum, the boundary colors (yellow, 
        cyan and magenta) are less prominent than the primary 
        colors; the stretched rainbow expands these ranges so that 
        all six colors (red, green, blue, yellow, cyan, magenta)
        are of equal size; has the best spectrum distribution 
  
#Plotting - HSB Colors

The plotting color system uses the HSB (Hue-Saturation-Brightness-Alpha) color system. To make colors in this system you start with a hue and add black (saturation) or white (brightness). This table shows some of the conventional terms used under this system:

Colour type   S      B

Black        Any     0%
White         0%    100%
Gray          0%    1-99%
Hue          100%   100%
Shade        100%   1-99%
Tint         1-99%  100%
Tone         1-99%  1-99%

For example, to make a brown shade you start with a yellow-red hue and shade it down to the brown by reducing the brightness.

The Alpha channel is transparency.

#Plotting - Line Styles

Some settings allow you to set a line style. In the line style there will be a thickness, color and dash pattern.

The dash pattern is a string. If you leave the box blank the line will be continuous. To indicate a dash pattern enter the number of pixels separated by spaces in the order line-gap-line-gap-... etc. You can specify as complex a pattern as you want. You can also specify a phase (where the pattern starts for every repetition) by appending a number separated from the rest of the string by a colon.

Example:

The dash pattern 4 2 3 1 would look like this (x's are pixels, -'s are gaps),

	XXXX--XXX-XXXX--XXX-XXXX--XXX-XXXX--XXX-XXXX--XXX-

By specifying a phase you can change where the pattern starts.
For example 4 2 3 1 : 2 looks like this,

	XX--XXX-XXXX--XXX-XXXX--XXX-XXXX--XXX-XXXX--XXX-

The phase must be greater than or equal to zero and cannot be greater than the total pattern length. For example, in the pattern above the total length is 4 + 2 + 3 + 1 = 10.

#Plotting - Multiple Plots

You can generate multiple plots all at once in several ways.

If you have dataset with more than 2 dimensions you can specify one of the constraints to be range of values. For example, if you had a dataset that was time, latitude and longitude, you could make latitude 'Y' and longitude 'X' and constraint time to be '1,2,5-8,11'. This would generate seven plots, one for each time value.

You can also multi-plot by creating thumbnails, selecting the thumbnails you want to plot by holding down the shift key and then pressing the plot button. All the selected thumbnails will be plotted.

#Plotting - Coastline

You can display a coastline by turning on the Show Coastline option in the Options tab.

If you have coastline data available it will be applied according to the following resolution cutoffs:

File        Description     Resolution  File Size  Cutoff
------------------------------------------------------------
gshhs_f.c   Full             0.04 km     87M       < 0.05 km
gshhs_h.c   High             0.2  km     20M       < 0.4 km
gshhs_i.c   Intermediate     1.0  km      5M       <  2 km
gshhs_l.c   Low              5.0  km      1M       < 10 km
gshhs_c.c   Crude           25    km    167K        

You can cause only the crude coastline to be used by setting the coastline path (in the configuration settings) to blank. You can also cause a particular file always to be used by setting the coastline path to that particular file. If you set the coastline path to a directory it will search the directory for the above files. The default directory is /coastline.

IMPORTANT: any resolution smaller than low (5 km) will use significant memory and time resources to load and process. Be cautious when using the coastline on data that covers a small region.

#Additional Tips

* In the GCMD search you can clear the info panel by clicking the area to the right of the info buttons
* By double-clicking in this area you can see the currently defined constraint
* Ctrl-clicking in this area will run whatever text is in this panel as a GCMD query
* Some servers especially NOAA/NASA servers may require longer timeouts

#Interpreter

The ODC uses the Jython interpreter as its scripting engine. Jython is a full-featured implementation of the Python programming language. This allows you to program the ODC with Python to manipulate data, generate plots, and do calculations. Python is the most powerful interpretive language available and there are many libraries written in Python which you can use to do calculations.

You can use the Editor window to interactively write Jython scripts (see Editor).

The interpreter is accessible from the View / Command window which acts as a command console. In this window you can enter commands and press Enter to execute them. If you want to execute a group of lines as a unit separate them with a backslash (\). You can also load complete files, called "modules". For more information about loading modules and blocks of code see the help topic "Interpreter - Modules". For more information about manipulating data using the interpreter see the help topic "Interpreter - Data Access".

As a simple example of using the interpreter go to the View / Command window and type:

	print 2+2

and press the Enter key. The console will respond with '4'. In a similar way you can type any valid Python expression.

The interpreter remembers previous commands which you can access with the up-arrow. Pressing the up-arrow key will cycle through previous commands.

Python is complex object-oriented language that you can find more information about at www.python.org. To find out about Jython go to www.jython.org.

#Interpreter  - Commands

The ODC interpreter has two main modes: ODC native commands and Jython interpreter commands. By default anything typed into the interpreter will be interpreted as a Python expression unless it begins with an exclamation point (!) in which case it is treated as an ODC native command. Examples of commands:

   !             ODC native commands begin with an exclamation point
   !help         ODC command help
   !reset        reset the interpreter environment, all variables deleted

   print [expr]       prints the value of an expression
   print sys.version  prints the version of Python being used
   print sys.modules  prints a list of the currently loaded modules
   print dir(opendap) prints a list of the functions in the 'opendap' module
   print 2+2          prints '4'

The ODC built in commands are not case-sensitive, but all expressions in Java and Python are case sensitive.

Complete list of Python built-in functions:

   http://www.python.org/doc/current/lib/built-in-funcs.html

#Interpreter  - Scripts

When working with Python you typically use a combination of pre-existing modules and scripts that you write. The default directory for such scripts is the /scripts directory which is in the ODC base directory. You may find some example scripts in this directory after you install the software.

To find out what modules are already imported into the current Python environment use the dir function, eg:

   >>> print dir()
   ['__doc__', '__name__', 'odcapi', 'opendap', 'sys']

You can also find out the functions in a module with the dir function, eg:

   >>> print dir(odcapi)
   ['dumps', 'help']

The editor (View / Editor) can be used to edit scripts or you can edit them in an outside text editor. To load the scripts you have created use the import function, eg:

   >>> import batch

Note that the ".py" extension is NOT included in the import command. The above statement would import the script named "batch.py" in the scripts directory.

Once a module is imported you can run functions in the script.

   >>> batch.replace()

If you make a change to your script and save the change you can reload the new version with the reload() function:

   >>> reload(batch)

#Interpreter  - Modules

Master list of standard Python modules: http://docs.python.org/modindex.html

List of nearly 3000 importable Python modules: http://cheeseshop.python.org

#Interpreter  - Java and ODC Data Access

To get access to any Java method import it using the full class name. For example, to determine the day of the week of January 17, 1823, you could give the following commands:

   >>> import java.util.GregorianCalendar
   >>> date18230117 = java.util.GregorianCalendar(1823,1,17)
   >>> import java.text.SimpleDateFormat
   >>> print java.text.SimpleDateFormat('EEEE').format(date18230117.getTime())
   Monday

Notice that in Python to create a new object instance you just use the constructor directly like a function; there is no "new" keyword as in Java.

To access data from the ODC an API object has been added to the environment called "odcapi". This object has its own help:

   >>> print odcapi.help()

The API class exposes data and functionality which we consider public and want to maintain permanently going forward. The methods in this class are designed for easy access and provide shortcuts to commonly needed data structures.

You are not restricted to using the public API to get information from the ODC. You can access any data structure or method in the application directly from the command window. The advantage to doing this is that it allows you to access any public variable in the application. The disadvantage to doing this is that there is no guarantee your code will work in future versions and most functionality inside of the application is undocumented so you will need to read the project source code in most cases to figure out what is accessible and how to access it.

As an example of accessing the ODC directly suppose you wanted to get the system memory status. You can get this information by double clicking the memory status bar anyway, but to do it with the command interpreter:

   >>> import opendap.clients.odc.ApplicationController
   >>> print opendap.clients.odc.ApplicationController.getInstance().sMemoryStatus()

#Data Viewer

The data viewer allows you to view, edit, save and load data sets in various formats. You can display plots of the data interactively as you edit it. You can also view the data in table like format which itself can be copy and pasted (ctrl-c and ctrl-v) into Excel or other spreadsheets. The spreadsheet display, called the "tabular viewer," can be saved as a comma-separated value (CSV) file which many programs such as Excel and databases such as Microsoft Access can import. When you display a variable in tabular form you can optionally include dimensional data vectors as the first row or column of the data. Note that you can only display one variable at a time and if the data has more than two dimensions you can only display a two-dimensional slice. The configuration options for the tabular viewer are located in the header of the table. This header can be hidden. The structure view panel for your data contains the controls to show or hide the viewing header as well as the type of view you want to see.

If you choose the plot view you will see a plot of the data instead of a tabular view. The plot view controls are on the plotter tab. You can save plotter configurations. If the plotter configuration which is open when the data is generated does not match the data then a default configuration will be automatically determined by the ODC.

#Data Viewer - Datasets

Datasets are bundles of data in the OPeNDAP or other formats. For full details on the specification of this format see the PDF /doc/DAP_4.0.pdf in the base directory where you installed the ODC. You can Load (open), Unload (close) existing datasets from the Data Viewer (View / Data tab). You can also create New datasets.

Dataset Titles:
                   When you load a dataset or create a new one, it's title will appear in the combo box in the upper left of the screen. Do not confuse the title of a dataset with its name. For example, a dataset loaded from the internet might have a automatically-generated title of "http://ndbc.noaa.gov/data/buoys/A31/20110127.cdf" but a name of "Woonsocket Soundings". The name is a label applied to the data itself. The title is the name associated with the file or source of the data. When you create new datasets use a title that would you like the data's filename to be. The name of the dataset can be more generic. For example, your dataset might have a title of "IceCore 20110402 McMurdoNE5", but the dataset name, which is applied to the uppermost structure can just be "Ice Core Series" because the other info will be in the attribute table for the dataset. You can change the title of a dataset by using the "Retitle" button at the far right of the button bar at the top of the screen.

Editing Datasets:
                   When you create a new dataset it will be automatically added to the list of datasets and activated. The structure of the dataset is shown in the "Dataset Structure" pane. Select any element of the structure to edit it. When a dataset is first created it is empty. There are four main operations you can do to a dataset element:

	Add Member (blue plus)      - adds a new element to the structure of the type shown in the drop-down box
	Delete (blue minus)         - deletes the current element (the top-level structure cannot be deleted)
	Move Up (blue up arrow)     - moves the element up if there is more than one and it is not at the top already
	Move Down (blue down arrow) - moves the element down if there is more than one and it is not at the bottom
	
You can also edit the characteristics of the element depending what it is. For example, an array element can have dimensions added/deleted/renamed and resized.

Creating Arrays: 
                   When you create new arrays they are automatically dimensioned to 100 elements and the dimension is given a generic name of "dim1". This is to give you a starting point with something to work with. You can add more dimensions, rename them and resize them. An array must have at least one dimension. You can view and edit the data your array contains in the tabular view at the bottom of the screen. You can paste data into this matrix, type or generate it using an expression (see the topic "Data Viewer - Expressions"). Note that you can use expressions to generate entire datasets, as well.

#Data Viewer - Dataset Structure

The Dataset Structure view is located in the left middle of screen on the Data / View tab. Topologically the view is a tree and looks like a file folder editor. It allows you to see and select elments from the overall structure of the dataset. The topmost element, the root of the structure, is the first "folder" in the tree. You can expand or collapse the tree branches by clicking the gray triangle icons next to the folders. Each folder is labeled with the name of the variable. When you select a variable (click on it once to select it), the corresponding variable is shown to the right in the "Define Variable" panel, and if applicable a view of the data in the variable is shown below in the array viewer. Not all variable types have an array view.

The following editing actions are possible using a selection from the Dataset Structure view:

	Delete a variable - Select the variable by clicking it once and pressing the blue "-" (minus) button in the Define Variable panel.
	                    You cannot delete the root structure.
						
	Change variable name - Select the variable by clicking it once and modifying the "Name" text box in the Define Variable panel.
	
	Change variable ordering - Select the variable you want to move by clicking it once.
                               Click the blue arrow up/down buttons Define Variable panel to change the variable's position.
							   
	Add a new variable -
	   (1) Select a structure variable (or the root structure)
	   (2) Select the type of variable wanted from the drop-down box next to the "+" button
              in the Define Variable panel. For example, "Array".
       (3) Click the "+" button. This will create a new variable with default characteristics
		      as the last member of the selected structure.
								
	Paste data to create a variable -
	   (1) Copy data from another source, such as a spreadsheet, or database program.
	          To copy usually Ctrl+C is used, or a menu command from an "Edit" menu.
	   (2) Select a structure variable (or the root structure) to contain the data.
       (3) Select the type of variable wanted from the drop-down box next to the "+" button
		      in the Define Variable panel. For example, "Array".
       (4) Press Ctrl+V to paste the data into the structure as a new variable.
									 
Note that when you paste data as a new variable the ODC needs to decide what kind of variable to create. It will take as a hint whatever variable type you select in the Define Variable panel. For example, if you select "Array" it will try to make the data into an array. If you select "Sequence", it will try to make a sequence. To type the data the ODC tries to parse it as different types with the following order of preference:
	
	Byte, Unsigned Short, Short, Unsigned Integer, Integer, Float32, Float64, String
	
Even a single string in the data will cause the whole dataset (if an array, or field if a sequence) to be typed as a String. If you want to coerce the data to be a particular type, create the variable yourself first (as in the "Add a new variable" instructions above) with the desired type. The dimensions do not matter--they will be overwritten by the paste. Then paste the data into the array view using the Ctrl+Alt+V key combination. This will size the array to match the paste and the values will be of the type you specified. See the topic "Data Viewer - Copy and Paste" for more information on this.	
				   
#Data Viewer - Array View

The array viewer is located in the bottom half of the Data / View tab and is shown when a dataset element of type array, grid or sequence is selected. This viewer looks like a spreadsheet and gives you a two-dimensional view of the data in the array. The view can be configured through the Define Variable panel to show different slices of a multi-dimensional array or to show different dimensions on the x- and y-axes. Using the array view you can edit the data in an array, copy it, paste new values in, and use expressions to modify or make special views of the data in the array.

When the array view is active it will be surrounded by a thin blue border. To activate in the array view click in it somewhere. Keystrokes will only take effect in the array view if it is active.

The top bar of the array viewer is the viewer's action bar. It contains the current selection coordinates "r" (row) and "c" (column) followed by a value editor (labeled "value:") and an expression one-line editor (labeled "exp:"). If you modify the selection coordinate cells and press enter the selection will jump to that coordinate.  The selection coordinate display can be toggled visible or invisible by clicking the "r:" button.

Value Text Box
              When a cell of the array is selected its value will appear in the value text box. If you change this value and press enter the value in the array will be changed to the new value. If you press Ctrl+Enter the entire selection will be set to the new value. The array viewer does not support in-cell editing. You can also edit cells by using the Value Editor panel located to the right of the Variable Editor (see the topic "Data Viewer - Value Editor" for more information about that interface). 
			  
Expression One-Liner
                      The expression editing combo box labeled "exp:" next to the value text box is called the expression "one-liner". It allows you to write quick expressions (formulas) to modify cell contents or create a "view" of cells. A view changes the way cells are displayed, but does not change the actual contents of the dataset. For example, you could use a view to see Celsius values in Farenheit without actually changing the dataset itself. Next to the one-liner is a mode drop-down. This controls the range of cells affected by the expression when the enter key is pressed (All, Selection, Value, View). For more information on the expression one-liner see the topic "Data Viewer - Expression One-Liner".

#Data Viewer - Array View Navigation and Selection

To navigate in the array view:

	arrow keys                     move the cursor one cell at a time
	Ctrl+arrow keys                move the cursor by one screen at a time
	PageUp/PageDown                moves the view up/down by a screen at a time
	Ctrl+PageUp/PageDown           moves the view diagonally by a screen
	Ctrl+Home                      moves the selection to [0][0]
	Ctrl+End                       moves the selection to the end of the slice
	Atl+PageUp/PageDown            moves the view to the next/previous page (ie slice)
	
The last mentioned control is only useful in data that has three or more dimensions.	
					  
	Shift+[navigation key]         extend the selection relative to the cursor position
	Ctrl+.                         rotate the cursor through the corners of the selection
	Tab                            move the cursor forwards through the selection
	Shift+Tab                      move the cursor backwards through the selection
	click header corner            select entire page
	click row header               select entire row
	Shift+Spacebar                 select entire row
	click column header            select entire column
	Ctrl+Spacebar                  select entire column
	Ctrl+A                         select the entire page
					  
#Data Viewer - Copy and Paste

You can copy and paste one-dimensional or two-dimensional information into and out of the data viewer. Select the cells desired and press Ctrl+C to copy. Press Ctrl+A to select all the cells in the current view. To paste into the array viewer the following key combinations are possible:

	Ctrl+C                copy
	Ctrl+A                select the entire page
	Ctrl+Spacebar         select the current column(s)
	Shift+Spacebar        select the current row(s)
	Ctrl+V                pastes data at the current selection, any extra data that does not fit will be ignored
	Ctrl+Shift+V          pastes data at the current selection, expands dimensions to accomodate data
	Ctrl+Alt+V            pastes data at [0][0], resizes dimensions to match data, any existing data on that page is overwritten

From the above you can see that you can instantly create a two-dimensional dataset by using the Ctrl+Alt+V combination. This will size the dataset to match the paste and then populate the array with the data from the paste. If you have a three-dimensional dataset you can use Ctrl+Alt+V to create the first two-dimensional page, add a third dimension, then paste in the z-order pages one at a time. To navigate through the z-order pages press Alt+PageUp.

Copy and paste in the Data Viewer only affects the currently selected variable. If you want to create a new variable with a paste, select a structure in the "Dataset Structure" tree view and paste there. See the topic Data Viewer - Dataset Structure for more information.

Note that copied values are strings corresponding to the current view of the data. For example, if the data is Celsius and you are currently using an expression to view it in Farenheit, then the copied values will be the Farenheit values. Likewise, if you are formatting the view to include symbols or letters, those will be copied, just as they appear in the array view. If strings are truncated in the view due to cells being too small, then the full-sized value string is copied, not the truncated string. If you want to copy the actual data values, turn off the view by clearing the "Exp:" text box and pressing enter.

When you paste data into the array view the data will always be forced into the type of the array. For example, if the array is of type Int32 then all the strings will be converted to integers. Any errors will cause the integer error value to be entered. If you want the ODC to attempt intelligent type recognition paste into the structure view, not the array view. See the topic "Data Viewer - Dataset Structure" for more information.

#Data Viewer - Search and Replace

Pressing Ctrl+F activates a search and replace dialog.

You can search and replace data using the dialog.
	
#Data Viewer - Expression One Liner

The expression one-liner is a combo box that allows you to write short expressions to modify data or create a view of the data as seen in the array viewer (View / Data, lower half of screen). An expression is a formula in Python that evaluates to a value. In general, this text box behaves similarly to expressions created in the Script Editor or Value Editor. The main difference is that it assumes you are only setting the "value" variable so you do not need an equation, you just write the R-value. For example, the one-liner:

	$1 + $2
	
with a mode setting of "All" will add the row number to the column number of the array and put it in the cell. The one-liner:

	$0 * 9 / 5 + 32
	
Will convert the cell from Celsius to Farenheit. "$0*9/5+32" would work just as well. If the mode selection is "All", Earthware will visit every cell in the currently selected dataset variable, even if it is not visible in the array view, substitute its current value for $0, evaluate the expression and put the result back in the cell. The old value in the cell is overwritten. The modes available are as follows:

	All        perform expression on every cell in dataset
	Selection  perform expression on every cell in the current selection
	Value      perform expression on current cell and put result in value text box
	Command    perform expression on current cell and put result in command window
	View       perform expression on cells as they render (do not change actual values)

If the mode is "Value", the expression will modify the value in the value text box and move the cursor to the "value:" text box. No data is modified until you press 'Enter' a second time. This allows you to see the results of a calculation before committing to a change in the data. If you press the 'Esc' key, the text box will revert to the current value of the cell without making changes.

If the mode is "View", no permanent changes to the data are made. The calculation is only done when the cell value is rendered to the screen, so the data remains the same, but its appearance in the viewer changes. This is useful when you want to see the results of a conversion or see data in a particular format without changing data. The formal term for this functionality is an "expression view".

To turn off a view clear the expression box and press enter.

One-Liner History
                  The one-liner combo box contains the history of one-liners you have saved. If you click the down arrow next to the box (or click an arrow key) it will show the list of previously saved one-liners. To save a one-liner hold down the 'Shift' key when you press enter. This will execute the one-liner and save it to the history at the same time. You can replace a one-liner by selecting it, editing it and pressing Ctrl+Shift+Enter. To save a one-liner without executing it, press Ctrl+Enter. Note that every time you execute a one-liner there will be an entry in the status logs (see the topic "Status and Errors") so you can always find a full record of your work there, even if you don't explicitly save the one-liner to the stored history. To delete a one-liner from the stored history, mouse over it to select it, and press the 'Delete' key. The stored history is saved in a file called "exp.txt" in your base directory. You can change the contents of the history by editing that file and restarting the ODC or making the command "!reload exp".

One-Liner Ranges
                  Even though it says "every cell" in the table above, this is only the default behavior. You can override the default range of a "Selection", "All" or "View" one-liner by using the same directives used to control range in scripts (see the topic "Data Viewer - Script Ranges" for full details). For example, let's imagine you were viewing a sequence with a field called 'Pressure' in Torrs and you wanted to view, but not convert, that field to mega Pascals (MPa). You could set the mode to "View" and then use the following one-liner:
				  
	#![]['Pressure']; $0 * 0.0001333
	
This one-liner tells the array viewer to only apply the one-liner to the 'Pressure' column. Since the mode is "View", no data will be changed. Note that the semi-colon is required. It indicates where the directive ends and the expression begins. See the "Data Viewer - Expression Ranges" for more information on how to control ranges.

One-Liner Labels
                  If you have a lot of stored one-liners it can be useful to label them. The ODC directive preprocessor specially supports this by allowing you to insert a comment immediately after the hash-bang like so:
				  
	#!Torr to MPa: []['Pressure']; $0 * 0.0001333
	#!Torr to MPa: $0 * 0.0001333
				  
In the first example there is an expression label, followed by a directive. In the second, the label is followed by an expression with no directive. When the preprocessor encounters an unknown string after the hash-bang it treats it as comment until a colon (":") is encountered, then it will look for a directive. If it finds no valid directive, it will regard the rest of the text as a Python expression.

One-Liner Errors
                   By default a one-liner will always stop on an error before doing a modification (modes: All and Selection), and will output the string "#Error#" when doing a view-type evaluation( modes: Value, Command and View). If you double-click a cell that has an error display the cell will be re-evaluated and any error generated will be shown and logged. It is a good idea to do a #!test one-liner or use view mode before running an expression on All, because that will irreversibly overwrite the data.

One-Liner Differences From Scripts
                                    
One-liners are evaluated in a different way than scripts and there are important differences between the two, mostly limitations on one-liners that scripts do not have. The main differences are as follows:
									
	- you cannot create a new dataset with a one-liner
	- you cannot change the size, shape or type of the data
	- you cannot trace the evaluation
	- script parameters like "value" and "type" are not defined
	
In general, the operating principle of a one-liner is that you can modify existing data or expression-view existing data using only the macro substitutions, $0 (the cell), and $1-$5, the dimensional index (up to five dimensions).

#Data Viewer - Scripts

Data Viewer scripts allow you to generate data using mathematical expressions and functions in the Python language. All scripts begin with the directive "#!odc". This can be useful in wide variety of ways. For example, using the scripting engine you can calculate a linear regression of a data set and then, using the layer capability of the plotter, overlay the regression line on a plot of the data. Scripts can be used for more mundane uses. For example, you might want to add a dimensional index numbers to a dataset that lacks them. You can also use scripts to modify existing data sets. For example, you can use the geodesic functions that are built into the ODC to perform transformations such as orthorectification on satellite data sets.

DON'T CONFUSE WITH PLOTTABLE EXPRESSIONS: Don't confuse data scripts with plottable scripts. A data script always defines the "value" (or $0) variable. A plottable script or expression (see topic "Plotting Expressions" above) defines cartesian or polar coordinates such as "x" or "y". If the ODC finds a "value" assignment it will treat the script as a data generator, if it finds a plottable coordinate it will treat the script as an formula expression, otherwise it will return an error when you try to run/plot the script. You can explicitly define the script type by using directives (see the topic "Script Directives"). For example, the directive "#!new" would cause the script to be treated as a data script.

There are three ways to use data scripting: create a full script in the text editor or data viewer, create a mini-script in the Value Editor panel, or create a one-liner in the array view panel. This rest of this topics applies only to full-size or mini-scripts. For information on one-liners see the topic "Data Viewer - Expression One Liner".

Scripts are stored as text files which are intended for use by the ODC's Python engine. The file is pre-processed, however, so its format is more restricted than a normal Python script file. At a minimum the file must define at least one output. For example, the statement

	#!odc
	value = 5
	
would create a 1-dimensional vector in which every single value is 5. Note that no type is defined and no dimensional ranges are defined. The default type is double and the default dimensional range is 1-100 with a step of 1, so in this case the end result would be a 100-member array in which each member is the double 5.00000. The identifier "value" is repetitively evaluated by the ODC using the Python engine. Whatever value that identifier has will be used as the variable value. Suppose we wanted a vector with the integer numbers 1 to 50 in it:

	#!odc
	type = "Int32"
	size = 50
	value = 1 + $1

The order of the parameters does not matter. The term $1 is a macro substitution referring to the current value of the index in the first dimension which begins at 0. The first dimension is the row. You can use up to 4 dimensions. You can also create recursive functions. For example, if we wanted a vector with the first 20 values of the fibonacci sequence the script would be:

	#!odc
	type = "Int32"
	size = 20
	value = if( $1 == 0 ) then 0, else if( $1 == 1 ) then 1, else value[$1 - 1] + value[$1 - 2]
	
From the above you can see that you can have the array refer to members of itself using the syntax value[x] where x is index number desired. Note that if the array member has not been defined yet its value will be null. So, for example, expressions like value[$1 + 1] will always be null. You cannot use array references as L-values. In other words, you can read from the array but you cannot write into it. For example, a line beginning value[1] = ... would be ignored by the preprocessor as invalid.

Value calculations can easily become unwieldy so you may wonder if it is possible to use intermediate values to calculate parts of the value separately and thereby break the calculation into several easier-to-understand sub-calculations. Yes, you can define and use other variables as you wish in your script file. Just be aware that there is a specific order of evaluation for the different expressions. See the help topic "Data Viewer - Intermediate Values" for more information.

To refer to existing data sets in an script first make sure they are loaded. If you look at the drop down list box at the top of the data viewer it has in it all of the loaded data sets. To refer to the data use the same syntax you would use for a constraint. For example:

	size = MyData.Variable1.length
	value = MyData.Variable1[$1] + 1
	
This script would create a new one-dimensional array in which each value was one greater than the corresponding value in the Variable1 array. Note that you do not have to specify the path to the variable. For example, if you have a nested dataset where the variable you want is, say, MyData.data.Structure5.array1 then you only need to reference MyData.array1 (where MyData is the title of the dataset). The ODC will search through the data structure for the occurrence of "array1" and use the first one it finds.

See "Data Viewer - Parameter Reference" for a listing of all the possible parameters in an expression set.

#Data Viewer - Script Directives

Scripts can be prefaced by special directives that control the target of the script and the range of cells to be operated on. Directives are indicated by a hash-bang "#!" and must end with a semicolon ";" if they are used in a one-liner. Python treats hashes ('#') as comments so the directives are ignored by the Python engine. They only have meaning to the ODC.

Script Directives (invalid for one-liners)

#!odc             all scripts must begin with this directive to identify it as an ODC script
#!new             generate a new dataset using the script (this is the default mode)
#!modify          modify the currently active dataset
#!modify_view     modify the active 2D array in the array view
#!modify MyData   modify the dataset called "MyData"
#!plot            generate data and plot it without saving the data

General Directives (can be used in one-liners and scripts)

#!test n          make no modifications, report up to n errors in the console
#![20-30]         restrict range to rows 21-31 (see topic "Data Viewer - Script Ranges" for details)
#!cursor          restrict range to cell where the cursor is
#!selection       restrict range to the active selection

If a directive is used in a one-liner it must be separated from the expression by a semi-colon. Note that the informational label can be used in conjunction with a directive and is typically used in one liners. For example:

      #!report first fifteen errors: test 15;

The first part of this directive ("report first fifteen errors") is an informational label. Informational labels must not begin with "test", "[", "cursor", or "selection", and must end with a colon.
	  
#Data Viewer - Modifying Data with Scripts

In addition to making new datasets, you can modify datasets with scripts. Use a directive to indicate that you want to do a modification. There are three typical types of directives to do this:

#!modify          modify the currently active dataset
#!modify_view     modify the active 2D array in the array view
#!modify MyData   modify the dataset called "MyData"

You can then create expressions to modify the data. For example, to convert a dataset from Celsius to Farenheit in the active dataset you could use the script:

#!modify
value = $0 * 9 / 5 + 32

Note that this is a little different than a one-liner because you have to use an L-value (the "value =" part) whereas in a one-liner you would just write the R-Value ("$0 * 9 / 5 + 32"). This is because a one-liner automatically assumes that the result of the expression will be applied to the value. You can also modify specific ranges. For example:

#!modify
#!selection
value = $0 * 9 / 5 + 32

Would convert to Farenheit only the selected cells in the active dataset. Note that the ODC remembers the selection for every loaded dataset, so even if a dataset is not currently active you can still refer to its last selection. If a dataset is freshly loaded the initial selection is the first element of the first variable, which is [0][0] in the case of a two-dimensional array.
	  
#Data Viewer - Parameter Reference

The parameter names are case-sensitive and must be lower-case to be recognized.

The complete set of predefined parameters and their default values is as follows:

	value = null
	type = "Float64"  (type name is not case-sensitive)
	allow_errors = false
	trace
	size_1 = 100
	size_2 = 0
	size_3 = 0
	size_4 = 0
	name_1 = "dimension_1";
	name_2 = "dimension_2";
	name_3 = "dimension_3";
	name_4 = "dimension_4";
	index_1_type = "Float64" (use these variables for single-vector grids)
	index_2_type = "Float64"
	index_3_type = "Float64"
	index_4_type = "Float64"
	index_1 = null 
	index_2 = null
	index_3 = null
	index_4 = null

	$0 is the macro substitution for the current value of the cell being operated on
	$1, $2, $3 and $4 are macro substitutions for index values as the expression set is evaluated
	
	$$ is the escape sequence to indicate a literal '$' in case you have the above strings ($0, $1, $2, $3 and $4) and you don't want them to be replaced.
	
Additional parameters that can be used to define multi-vector grids:

	index_1_1_name = "dim1_index1"
	index_1_2_name = "dim1_index2"
	index_1_3_name = "dim1_index3"
	index_2_1_name = "dim2_index1"
	index_2_2_name = "dim2_index2"
	index_2_3_name = "dim2_index3"
	index_3_1_name = "dim3_index1"
	index_3_2_name = "dim3_index2"
	index_3_3_name = "dim3_index3"
	index_4_1_name = "dim4_index1"
	index_4_2_name = "dim4_index2"
	index_4_3_name = "dim4_index3"
	index_1_1_type = "Float64"
	index_1_2_type = "Float64"
	index_1_3_type = "Float64"
	index_2_1_type = "Float64"
	index_2_2_type = "Float64"
	index_2_3_type = "Float64"
	index_3_1_type = "Float64"
	index_3_2_type = "Float64"
	index_3_3_type = "Float64"
	index_4_1_type = "Float64"
	index_4_2_type = "Float64"
	index_4_3_type = "Float64"
	index_1_1 = null;
	index_1_2 = null;
	index_1_3 = null;
	index_2_1 = null;
	index_2_2 = null;
	index_2_3 = null;
	index_3_1 = null;
	index_3_2 = null;
	index_3_3 = null;
	index_4_1 = null;
	index_4_2 = null;
	index_4_3 = null;
	
Python is an untyped language. The ODC takes whatever value Python generates and attempts to convert it to an OPeNDAP/IEEE type. If the conversion fails you will either get an error or a passive warning depending on the value of the $allow_errors variable. The supported type descriptors (not case-sensitive) are:

	Byte
	Int16
	UInt16
	Int32
	UInt32
	Float32
	Float64
	String

The index variables are L-values you can use to create grids. Normally dimension 1 is x, dimension 2 is y, dimension 3 is z and dimension 4 is time, but in some applications the dimensions could have other meanings. See the help section "Data Viewer - Grid Expressions" for more information on creating grids and the use of these variables. The size of the index arrays is determined by the size of the array they index.

#Data Viewer - Mini Scripts

In the data viewer's "Value Editor" panel is a text pane you can use to create mini-scripts along with a target selector ("All", "View", etc). A mini script operates the same way as a full size script, except that you can specify a target, which you cannot do with a full-size script. Mini scripts are useful when you want to do small-scale editing and viewing, but need a multi-line script that goes beyond the capabilities of the one-liner interface.

Note that you can only have one view expression active at a given time and the mini script panel takes precedence over the one-liner. If you have both set to "View", the one-liner will be ignored and only the mini script will be used.

#Data Viewer - Script Ranges

To control the range over which a script does a modification you can use range directives. By default a script will be executed against every value in the active dataset. Range restrictions are ignored if a new (#!new) dataset is being generated. Directives are entered as Python comments followed an exclamation point, or what is known as a hash-bang in programming parlance, for example:

	#![10][15]

This directive, placed normally at the beginning of the script, restricts the range to a single cell of the array (or grid or sequence), which is row 11, column 16. Index numbers are 0-based so the 5th row has an index number of "4", for example. When working with sequences the field name can be used in lieu of an index number:

	#![10]['Temperature']

This would restrict the operative range to a single cell as well: the 11th record, field named 'Temperature'. You can specify ranges with dashes, and use commas to separate multiple ranges:

	#![10-90,100-120]

If brackets are omitted or left blank then there is no constraint, every index number is allowed:

	#![][50-80]
	#![][90-]

The first example would be every row, columns 51-81. The second example is every row, columns 91 to the end. You can also specify the active cell or active selection (as indicated in the array viewer):

	#!cell
	#!selection
	
Earthware remembers the last selected cell, and selection range for every loaded dataset, so if the dataset is not being currently viewed, then the range will be constrained to whatever the last selection was. This allows you to select a range in one dataset, activate a different dataset, then perform some mutual calculation using the two selections.

Expressions can be used to control ranges, but be aware that the range directive is evaluated before anything else in the expression.

#Data Viewer - Script Errors

The "allow_errors" parameter allows you to control how errors are handled when your script is executed. By default this parameter is false so if an error occurs execution halts and an error is generated. If you want to allow errors in your data and continue execution even when errors occur set this value to true. In this case the data value that is in error will have one of the following values depending on its type:

	Byte	255
	Int16	-32768
	UInt16	65535
	Int32	-2147483648
	UInt32	4294967295
	Float32	NaN
	Float64	NaN
	String	#ERROR#

Note that some errors are fatal and will result in process termination regardless of the allow_errors setting. For example, if there is an error evaluating the script for a dimensional size then nothing further can be done and an error will be returned.

Python errors are different than ODC-related errors. If a Python error occurs it will say Python syntax error or Python error. In this case you need to check the syntax or content of your script to make sure it is correct Python. Other errors indicate a problem with ODC-specific processing and there will usually be a detailed error message describing the problem.

#Data Viewer - Debugging Script

The "trace" parameter enables you to debug the operation of your expression. With no parameters supplied every loop through the data will be traced. Beware that the trace will generate up to a page of text for every loop through the data. So if you are generating a million-member array with tracing on for all points the ODC will attempt to send a million pages of text to your text viewer and probably bring your system to its knees. To control which loops are traced use the following syntax:

	trace 5 15 0
	
This would tell the system to trace only the generation of the data value [5][15][0] in the dataset. You can also specify ranges using dashes:

	trace 5-11 15 0-2

This would trace elements [5-11][15][0-2]. There would be 21 traces in this case (7 x 1 x 3).

All trace output is sent to the text viewer (View/Text).
	
#Data Viewer - Intermediate Values

If your script formulas are complicated you may want to break them into easier-to-understand sub-calculations using intermediate values or variables. The key thing when doing this is to understand the order of evaluation of the different statements you place in your expression file which is as follows:

(0) Tracing parameter is evaluated if present

(1) Range directives are evaluated if present

(2) All unrecognized variables beginning with "__" are evaluated.

(3) The configuration values (allow_errors, type, name, and index_dimensions) are evaluated first in that order.

(4) The size variables are evaluated to determine the dimensions of the value array.

(5) The internal index values are incremented.

(6) All unrecognized variables beginning with "_" are evaluated after macro substitution.

(7) The index variables are evaluated

(8) All unrecognized variables not beginning with "_" are evaluated after macro substitution.

(9) The value variable is evaluated.

(10) The process loops to step (5) and continues until the value matrix is full.

Steps (6) and (8) are your chance to define intermediate values that are used to calculate (7) and (9). You can also designate variables to be evaluated once at the beginning of the variable creation by prefixing them with "__". See the section "Data Viewer - Grid Expressions" for examples of using intermediate expressions.
	
#Data Viewer - Grid Scripts

The help section "Data Viewer - Scripts" describes how to create simple vectors and matrices using scripts. You can also use scripts to create grids. Grids are vectors or matrices with quantified indices. For example, if you have a satellite image you may like to know what the coordinates of each pixel in the image are. This is what the grid indices tell you. To create a grid with the constant value of 5 with the indices going from 180 to 210 in the "x" direction (longitude) and 40 to 60 in "y" direction (latitude) you would write:

	type = "Int32"
	size_1 = 31
	size_2 = 21
	index_1 = 180 + $1
	index_2 = 40 + $2
	value = 5
	
The presence of the "index_n" variables tells the ODC you want to make a grid instead of a plain array. The order of the parameters does not matter. Note that the sizes in this example need to be 31 and 21 because a range of 180 to 210 has 31 elements in it and a range of 40 to 60 has 21 elements in it. Index 1 is in the "x" direction because the Python, C and Java all use row-major order which is value[x][y][z]. This differs from MATLAB which uses column-major order ([z][y][x]).

This will produce the following grid where every single value is the number 5:

	....
	
A key thing to note about grids is that the index arrays will always be the same size as the dimensions they index. This is why you only need one set of "size" expressions.

The $index_dimensions variable is used to create multi-dimensional grid indices. This is useful when the coordinates of an array vary continuously. One application is to do map projections. Another use is storing satellite datasets and other raw earth imagery. Multi-dimensional indices vary continously over each cell in the value matrix. For example, if you are creating a matrix with a multi-dimensional index then the grid will have two or three vectors for the indices. If your coordinate matrices need only 2 dimensions (e.g., latitude and longitude) then there will three arrays: the value array, the index_1 array (longitude), and the index_2 array (latitude). If your coordinate matrices need 3 dimensions (e.g., ECEF coordinates have x, y and z) then there will four arrays: the value array, the index_1 array (x), the index_2 array (y) and the index_3 array (z). In the last example, the index arrays will tell the exact ECEF coordinates of each pixel in the image.

Example: Creating an ECEF Grid

To create an earth-centered, earth-fixed (ECEF) grid we could use the following script:

	#!odc
	type = "Int32"
	value = 5
	size_1 = 651
	index_1_type = "Float64"
	index_1_1_name = "x"
	index_1_2_name = "y"
	index_1_3_name = "z"
	index_1_1 = radius_of_curvature * math.cos( latitude_radians ) * math.cos( longitude_radians )
	index_1_2 = radius_of_curvature * math.cos( latitude_radians ) * math.sin( longitude_radians )
	index_1_3 = radius_of_curvature * ( 1 - __eccentricity_squared ) * math.sin( latitude_radians )
	__earth_equatorial_radius = 6378.1370
	__earth_polar_radius = 6356.7523
	__earth_oblateness = (( __earth_equatorial_radius - __earth_polar_radius ) / __earth_equatorial_radius )
	__eccentricity_squared = 2 * __earth_oblateness - math.pow( __earth_oblateness, 2 )
	_longitude = 180 + $1
	_latitude = 40 + $2
	_longitude_radians = longitude * math.pi / 180
	_latitude_radians = longitude * math.pi / 180
	_radius_of_curvature = __earth_equatorial_radius / math.sqrt( 1 - __eccentricity_squared * math.pow( math.sin( latitude_radians ) ) )

This will create the grid as the previous example except that the index will be a three arrays containing the ECEF coordinates of the values instead of two vectors containing the latitude and longitude coordinates. Note that the "__" variables are evaluated only once at the beginning of the run and the "_" variables are evaluated before the index values (index_1_1, index_1_2, index_1_3) are evaluated.

#Desired Features
circular/coverage plots
track plots	












